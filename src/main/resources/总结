一、实现多线程的最简单的两种方式：
1、继承Thread类重写run()方法，new对象调用start方法实现线程启动
2、实现Runnable接口实现run()方法，在启动的多线程的时候，需要先通过Thread类的
   构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方
   法来运行多线程代码。
3、run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread
   类实际上也是实现了Runnable接口的类。
4、实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管
   是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的
   API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。
5、如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则
   很容易的实现资源共享。（Thread和Runnable的区别）

二、实现Runnable接口比继承Thread类所具有的优势
1、适合多个相同的程序代码的线程去处理同一个资源
2、可以避免java中的单继承的限制
3、增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
4、线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类

三、注意
1、main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，
   哪个先执行，完全看谁先得到CPU的资源。
2、在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。
   因为每当使用java命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个ｊＶＭ
   实际在就是在操作系统中启动了一个进程。

四、线程状态转换
1、新建状态（New）：新创建了一个线程对象。
2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。
   该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。
   直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
    a、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
    b、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
    c、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。
       当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
       （注意,sleep是不会释放持有的锁）
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

五、线程调度
 1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。
    1）Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
        static int MAX_PRIORITY    线程可以具有的最高优先级，取值为10。
        static int MIN_PRIORITY    线程可以具有的最低优先级，取值为1。
        static int NORM_PRIORITY    分配给线程的默认优先级，取值为5。
    2）Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
    3）每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。
    4）线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。
    5）JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，
       应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。
 2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，
    以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
 3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法
    或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。
 4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
 5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，
    直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
 6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，
    则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，
    在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以
    常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面
    没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。
  注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向

六、常用方法说明
 1、sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）

 2、join():指等待t线程终止。
    1） 使用方式：join是Thread类的一个方法，启动线程后直接调用，即join()的作用是：“等待该线程终止”，
        这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，
        只有等到子线程结束了才能执行。
        Thread t = new Thread(); t.start(); t.join();
    2） 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子
        线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待
        子线程执行完成之后再结束，这个时候就要用到join()方法了。

 3、yield():暂停当前正在执行的线程对象，并执行其他线程。
    1） yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。
        因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到
        让步目的，因为让步的线程还有可能被线程调度程序再次选中。
    2）yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行
        状态，但有可能没有效果。可看上面的图。
    3）sleep()和yield()的区别):
        a、sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是
            使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态 后马上又被执行。
        b、sleep() 方法使当前运行中的线程睡眼一段时间，进入不可运行状态，这段时间的长短是由程序设定的，
            yield 方法使当前线程让出 CPU 占有权，但让出的时间是不可设定的。实际上，yield()方法对应了
            如下操作：先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把 CPU  的占有权交给
            此线程，否则，继续运行原来的线程。所以yield()方法称为“退让”，它把运行机会让给了同等优先级
            的其他线程。
        c、另外，sleep()方法允许较低优先级的线程获得运行机会，但 yield()  方法执行时，当前线程仍处在
            可运行状态，所以，不可能让出较低优先级的线程些时获得 CPU 占有权。在一个运行系统中，如果较
            高优先级的线程没有调用 sleep 方法，又没有受到 I\O 阻塞，那么，较低优先级线程只能等待所有
            较高优先级的线程运行结束，才有机会运行。

 4、setPriority(): 更改线程的优先级。

 5、interrupt():不要以为它是中断某个线程！它只是给线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出异常，
    从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！

 6、wait()
    1）Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，
        从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获
        取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，
        并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，
        而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，
        赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以
        暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。
    2）对Object.wait()，Object.notify()的应用最经典的例子，应该是三线程打印ABC的问题：
        A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。
        这个问题用Object的wait()，notify()就可以很方便的解决。代码

